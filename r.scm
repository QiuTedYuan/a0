(define list-sum (lambda (alist)
		   (if (nullp alist)
		       0
		       (if (listp alist)
			   (+ (list-sum (car alist)) (list-sum (cdr alist)))
			   alist))))
(define matrix (lambda (data_m nrow ncol)
		 (if nrow
		     (cons (list-head data_m (- ncol 1))
			   (matrix (list-tail data_m ncol) (- nrow 1) ncol))
		     nil)))
(define mprint (lambda (mat)
		 (if (not (nullp mat))
		     (begin
		       (print (car mat))
		       (if (not (nullp (cdr mat)))
			   (mprint (cdr mat))
			   nil))
		     nil)))
(define mtranspose (lambda (mat)
		     (if (or (nullp mat) (nullp (car mat)))
			 nil
			 (cons (_map car mat)
			       (if (nullp (car mat))
				   nil
				   (mtranspose (_map cdr mat)))))))
(define mcount-row (lambda (mat) (length mat)))
(define mcount-col (lambda (mat) (length (car mat))))
(define mcount-elem (lambda (mat) (* (mcount-row mat) (mcount-col mat))))
(define mref-row (lambda (mat m)
	       (list-ref mat (- m 1))))
(define mref-col (lambda (mat n)
		   (mref-row (mtranspose mat) n)))
(define mref-elem (lambda (mat m n)
	       (list-ref (mref-row mat m) (- n 1))))

(define mdrop-row (lambda (mat m)
		    (if (= m 1)
			(list-tail mat m)
			(if (= m (mcount-row mat))
			    (list-head mat (- m 2))
			    (append (list-head mat (- m 2)) (list-tail mat m))))))
(define mdrop-col (lambda (mat n)
		    (mtranspose (mdrop-row (mtranspose mat) n))))
(define mdrop-elem (lambda (mat m n)
		     (mdrop-col (mdrop-row mat m) n)))
(define m= (lambda (mat1 mat2)
	     (equal? mat1 mat2)))
(define mnegation (lambda (mat)
	     (if (nullp mat)
		 nil
		 (if (listp mat)
		     (cons (mnegation (car mat))
			   (mnegation (cdr mat)))
		     (- mat)))))
(define m+ (lambda (mat1 mat2)
	     (if (type-equal? mat1 mat2)
		 (if (nullp mat1)
		     nil
		     (if (listp mat1)
			 (cons (m+ (car mat1) (car mat2))
			       (m+ (cdr mat1) (cdr mat2)))
			 (+ mat1 mat2)))
		 error)))
(define m- (lambda (mat1 mat2)
	     (m+ mat1 (mnegation mat2))))
(define m* (lambda (mat1 mat2)
	     (if (type-equal? mat1 mat2)
		 (if (nullp mat1)
		     nil
		     (if (listp mat1)
			 (cons (m* (car mat1) (car mat2))
			       (m* (cdr mat1) (cdr mat2)))
			 (* mat1 mat2)))
		 error)))
(define m/ (lambda (mat num)
	     (if num
		 (if (nullp mat)
		     nil
		     (if (listp mat)
			 (cons (m/ (car mat) num)
			       (m/ (cdr mat) num))
			 (/ mat num)))
		 error)))		 
(define msymmetricp (lambda (mat)
		      (equal? (mtranspose mat) mat)))
(define mmult (lambda (mat1 mat2)
		(if (!= (mcount-col mat1) (mcount-row mat2))
		    error
		    (if (= 1 (mcount-row mat1))
			(if (= 1 (mcount-col mat2))
			    (matrix (list (list-sum (map * (mref-row mat1 1) (mref-col mat2 1)))) 1 1)
			    (list (cons (list-sum (map * (mref-row mat1 1) (mref-col mat2 1)))
					(car (mmult mat1 (mdrop-col mat2 1))))))
			(append (mmult (list (mref-row mat1 1)) mat2)
				(mmult (mdrop-row mat1 1) mat2))))))
(define list-to (lambda (x)
		  (if (= x 1)
		      (list x)
		      (append (list-to (- x 1)) (list x)))))

(define mminor (lambda (mat i j)
		(* (if (even? (+ i j)) 1 -1)
		   (mdet (mdrop-elem mat i j)))))
(define mdet (lambda (mat)
	       (let ((_row (mcount-row mat))
		     (_col (mcount-col mat)))
		 (if (!= _row _col)
		     error
		     (if (= _row 1)
			 (car (car mat))
			 (list-sum (map (lambda (x)
					  (* (mref-elem mat 1 x)
					     (mminor mat 1 x))) (list-to _row))))))))
(define madj (lambda (mat)
		   (let ((_row (mcount-row mat))
			 (_col (mcount-col mat)))
		     (if (!= _row _col)
			 error
			 (if (= _row 1)
			     mat
			     (map (lambda (i)
				    (map (lambda (x)
					   (mminor mat x i))
					 (list-to _col)))
				  (list-to _row)))))))
(define minverse (lambda (mat)
		   (let ((_d (mdet mat)))
		     (if _d
			 (m/ (madj mat) (+ 0.0 _d))
			 error))))